import _ from "lodash"
import { BaseService } from "medusa-interfaces"
import { MedusaError } from "medusa-core-utils"

/**
 * Handles Fulfillments
 * @implements BaseService
 */
class FulfillmentService extends BaseService {
  constructor({
    totalsService,
    shippingProfileService,
    fulfillmentProviderService,
  }) {
    super()

    /** @private @const {TotalsService} */
    this.totalsService_ = totalsService

    this.shippingProfileService_ = shippingProfileService

    this.fulfillmentProviderService_ = fulfillmentProviderService
  }

  async partitionItems_(shipping_methods, items) {
    let updatedMethods = []
    // partition order items to their dedicated shipping method
    await Promise.all(
      shipping_methods.map(async method => {
        const { profile_id } = method
        const profile = await this.shippingProfileService_.retrieve(profile_id)
        // for each method find the items in the order, that are associated
        // with the profile on the current shipping method
        if (shipping_methods.length === 1) {
          method.items = items
        } else {
          method.items = items.filter(({ content }) => {
            if (Array.isArray(content)) {
              // we require bundles to have same shipping method, therefore:
              return profile.products.includes(content[0].product._id)
            } else {
              return profile.products.includes(content.product._id)
            }
          })
        }
        updatedMethods.push(method)
      })
    )
    return updatedMethods
  }

  /**
   * Retrieves the order line items, given an array of items.
   * @param {Order} order - the order to get line items from
   * @param {{ item_id: string, quantity: number }} items - the items to get
   * @param {function} transformer - a function to apply to each of the items
   *    retrieved from the order, should return a line item. If the transformer
   *    returns an undefined value the line item will be filtered from the
   *    returned array.
   * @return {Promise<Array<LineItem>>} the line items generated by the transformer.
   */
  async getFulfillmentItems_(order, items, transformer) {
    const toReturn = await Promise.all(
      items.map(async ({ item_id, quantity }) => {
        const item = order.items.find(i => i._id.equals(item_id))
        return transformer(item, quantity)
      })
    )

    return toReturn.filter(i => !!i)
  }

  /**
   * Checks that a given quantity of a line item can be fulfilled. Fails if the
   * fulfillable quantity is lower than the requested fulfillment quantity.
   * Fulfillable quantity is calculated by subtracting the already fulfilled
   * quantity from the quantity that was originally purchased.
   * @param {LineItem} item - the line item to check has sufficient fulfillable
   *   quantity.
   * @param {number} quantity - the quantity that is requested to be fulfilled.
   * @return {LineItem} a line item that has the requested fulfillment quantity
   *   set.
   */
  validateFulfillmentLineItem_(item, quantity) {
    if (!item) {
      // This will in most cases be called by a webhook so to ensure that
      // things go through smoothly in instances where extra items outside
      // of Medusa are added we allow unknown items
      return null
    }

    if (quantity > item.quantity - item.fulfilled_quantity) {
      throw new MedusaError(
        MedusaError.Types.NOT_ALLOWED,
        "Cannot fulfill more items than have been purchased"
      )
    }
    return {
      ...item,
      quantity,
    }
  }

  /**
   * Creates fulfillments for an order.
   * In a situation where the order has more than one shipping method,
   * we need to partition the order items, such that they can be sent
   * to their respective fulfillment provider.
   * @param {string} orderId - id of order to cancel.
   * @return {Promise} result of the update operation.
   */
  async createFulfillment(order, itemsToFulfill, metadata = {}) {
    const lineItems = await this.getFulfillmentItems_(
      order,
      itemsToFulfill,
      this.validateFulfillmentLineItem_
    )

    const { shipping_methods } = order

    // partition order items to their dedicated shipping method
    const fulfillments = await this.partitionItems_(shipping_methods, lineItems)

    return Promise.all(
      fulfillments.map(async method => {
        const provider = this.fulfillmentProviderService_.retrieveProvider(
          method.provider_id
        )

        const data = await provider.createOrder(method.data, method.items, {
          ...order,
        })

        return {
          provider_id: method.provider_id,
          items: method.items,
          data,
          metadata,
        }
      })
    )
  }

  async createShipment(order, fulfillment, trackingNumbers, metadata) {
    return {
      ...fulfillment,
      tracking_numbers: trackingNumbers,
      shipped_at: Date.now(),
      metadata: {
        ...fulfillment.metadata,
        ...metadata,
      },
    }
  }
}

export default FulfillmentService
